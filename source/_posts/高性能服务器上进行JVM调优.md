---
title: 高性能服务器上进行JVM调优
date: 2019-04-26 10:25:37
tags:
    - jvm
categories:
    - Java
---
本文介绍的是如何在高性能即高配置的服务器上进行JVM优化，为了充分利用高性能服务器的硬件资源，可以采用以下措施进行优化
### 采用64位操作系统，并为JVM分配大内存
如果JVM中堆内存太小，就会频繁地发生垃圾回收，而垃圾回收都会伴随不同程度的程序停顿，因此如果扩大堆内存的话就可以减少垃圾回收的频率，从而避免程序的停顿。因此首先想到的就是扩大内存容量。而32位的操作系统理论上支持的最大内存只有4G，但是64位的操作系统最大却可以支持到128G的内存；综上所述我们可以使用64位的操作系统和64位的JVM，并为JVM分配更大的堆内存。但“幸福的烦恼”也随之而来。
堆内存变大后，固然垃圾收集的频率减少了，但每次垃圾回收的时间将会变长。如果堆内存为14G，那么每次Full GC的时间将长达数十秒。如果Full GC频繁发生，那么对于任何一个网站或者程序来说都是是无法忍受的。
因此，对于使用大内存的程序来说，一定要减少Full GC的频率，如果每天只有一两次Full GC，而且发生在低峰时间段内， 那完全可以接受。
### 减少Full GC 频率
为了减少Full GC的频率则需要尽量避免太多对象进入到老年代，有下列做法可以参考：
#### 确保对象都是“朝生夕死”的 
一个对象使用完后应尽快让他失效，然后尽快在新生代中被Minor GC回收掉，尽量避免对象在新生代中停留太长时间。
#### 提高大对象直接进入老年代的门槛
通过设置参数-XX:PretrnureSizeThreshold来提高大对象的门槛，尽量让对象都先进入新生代，然后尽快被Minor GC回收掉，而不要直接进入老年代。 
#### 避免大对象
大对象对于JVM来说是个噩耗。如果对象过大，当前新生代的剩余空间装不下它，那么就需要使用分配担保机制，将当前新生代的对象都复制到老年代中，给大对象腾出空间，分配担保涉及到大量的复制，因此效率很低。如果将大对象直接放入老年代，虽然避免了分配担保过程，但该对象只有当Full GC时才能被回收，而Full GC的代价是高昂的。如果大对象过多时，老年代很快就装满了，这时就需要进行Full GC，如果Full GC频率过高，程序就会变得很卡。
对于大对象可以参考一下几种处理方法
* 在写程序的时候尽量避免大对象
从源头降低大对象的出现，尽量选择空间利用率较高的数据结构存储。
* 尽量缩短大对象的有效时间
对象用完后尽快让它失效，好让垃圾收集器尽快将他回收，避免因在新生代呆的时间过长而进入老年代。

