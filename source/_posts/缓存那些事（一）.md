---
title: 缓存那些事（一）
date: 2018-09-29 10:30:31
tags:
    - redis
    - 缓存
    - 缓存穿透
    - 缓存并发
categories: Java
---


在日常的开发工作中程序猿会用到各种各样的缓存软件，不管是Redis还是Memcached抑或是其它类型的缓存软件，都会遇到**缓存穿透**、**缓存并发**、**缓存失效**三类问题
#### 缓存穿透
<center>![缓存](缓存1.png)</center>
上图是大家使用缓存组件最常见的一个场景，那么它会有什么潜在的风险呢？
在项目中使用缓存时通常都是先检查缓存中是否存在，如果存在直接返回缓存内容，如果不存在就直接查询数据库然后再缓存查询结果返回。这个时候如果我们查询的某一个数据在缓存中一直不存在，就会造成每一次请求都查询DB，这样缓存就失去了意义，在流量大时，可能DB就挂掉了。
那么该如何解决这个问题呢？要是有人利用不存在的key频繁攻击我们的应用，这就是我们程序的漏洞。
一种处理方法是将这个不存在的key预先设定一个值，比如("key" , "&&")，在返回这个"&&"值的时候，我们的应用就可以认为这是不存在的key，那我们的应用就可以决定是否继续等待继续访问，还是放弃掉这次操作。如果继续等待访问，过一个时间轮询点后，再次请求这个key，如果取到的值不再是&&，则可以认为这时候key有值了，从而避免了透传到数据库，从而把大量的类似请求挡在了缓存之中。
还有一种处理办法是将系统中所有的key及对应的数据预先缓存起来，在系统中数据发生变更的时候，将单个变更的数据同步至缓存中，这样也可以避免出现缓存传统的情况发生，当然这种处理办法只适用于特定的业务场景。
#### 缓存并发
某些情况如果网站并发访问很高，某一个热点的缓存如果在此时失效，可能出现多个进程同时查询DB且同时设置缓存的情况，如果并发确实很大，这也可能造成DB压力过大，还有缓存频繁更新的问题。我们可以对缓存查询加锁，如果KEY不存在，就加锁，然后查DB入缓存，然后解锁；其他进程如果发现有锁就等待，然后等解锁后返回数据或者进入DB查询。这种处理方法和上述说的预先设定值问题有些类似，只不过利用锁的方式，但是会造成部分请求等待。
#### 缓存失效
平时我们都会设定一个缓存的过期时间，有一些会设置1分钟、5分钟等等;在高并发的时候可能会出在某一个时间同时生成了很多的缓存，并且过期时间都一样，当过期时间到后，这些缓存同时失效，请求会全部转发到DB，DB可能会压力过重。
那么该如何解决这个问题呢？最简单的处理方式是将缓存失效时间分散开，比如我们可以在原有的失效时间基础上增加一个随机值（1-5分钟随机），这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。

**参考资料**

* [程序猿DD](http://blog.didispace.com/chengchao-huancun-zuijiazhaoshi/)
* [深入分布式缓存：从原理到实践](https://item.jd.com/12276070.html?jd_pop=71fe8a90-8a79-414c-9e6b-8bf328f74494&abt=3)


